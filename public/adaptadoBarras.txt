    carregarTiposPdvc(1);    
    tipoBusca = ''
    async function carregarTiposPdvc(controle) {
    try {
      const emitente = await fetch(`/emitente/${controle}`).then(r => r.json());
      const tipo = emitente.tipodebusca.toUpperCase();
      const valorRadio = tipo === "CONTROLE" ? "controle" : "codbarras";
      document.querySelector(`input[name="tipoBusca"][value="${valorRadio}"]`).checked = true;    
      tipoBusca = document.querySelector('input[name="tipoBusca"]:checked').value;
      console.log("Tipo de busca selecionado:", tipoBusca);
    } catch (err) {
    console.error("Erro ao carregar emitente:", err);
    }
    }
    document.querySelectorAll('input[name="tipoBusca"]').forEach(radio => {
    radio.disabled = true;
    });

    if (entrada.includes('*')) {    
    const [quantidadeStr, controleStr] = entrada.split('*');       
    quantidade = parseFloat(quantidadeStr.trim().replace(',', '.'));     
    quanti = quantidade
    // Controle só inteiro
    if (!/^\d+$/.test(controleStr.trim())) {     
        if (tipoBusca === 'controle') 
        {
        resultado = "⚠️Entrada inválida. Exemplo: 2*1234";            
        showToast(resultado, 2500);       
        }          
        else
        {resultado = "⚠️Entrada inválida. Exemplo: 2*7898528977415";            
        showToast(resultado, 2500);      
        }
        throw new Error("Controle deve ser um número inteiro válido");
        
    }
    controle = parseInt(controleStr.trim(), 10);
    await handleEntradac(controle, tipoBusca, quantidade);

} else {    
    quantidade = 1;

    if (!/^\d+$/.test(entrada.trim())) {
        if (tipoBusca === 'controle') 
        {
        resultado = "⚠️Entrada inválida. Exemplo: 1234";            
        showToast(resultado, 2500);       
        }          
        else
        {resultado = "⚠️Entrada inválida. Exemplo: 7898528977415";            
        showToast(resultado, 2500);      
        }
        throw new Error("Controle deve ser um número inteiro válido");
    }
    controle = parseInt(entrada.trim(), 10);
    await handleEntradac(controle, tipoBusca, quantidade);
}


async function buscarProdutoc(tipo, valor) {
  if (tipo === 'controle') return await buscarProdutoPorControlec(valor);
  if (tipo === 'codbarras') return await buscarProdutoPorCodBarrasc(valor);
  throw new Error("Tipo de busca inválido");
}

async function handleEntradac(valor, tipoBusca, quantidade = 1) {
  const produto = await buscarProdutoc(tipoBusca, valor);
  if (!produto && srt ==1) {
    showToast("⚠️ Produto " + produtonome + " não fracionado no Estoque!", 2500);      
    document.getElementById("entra").value = "";
    produtonome = ''
    srt = 0
    return;
  }  
  if (!produto) {
    showToast("⚠️ Produto não encontrado!", 2500);
    document.getElementById("entra").value = "";
    return;
  }  

  const estoqueAtualizadoc = await aumentarEstoque(produto.controle, quantidade);
    if (!estoqueAtualizadoc) {
    resultado = "❌Erro ao atualizar estoque!";            
    showToast(resultado, 2500);                   
    document.getElementById("entra").value = "";        
    return;
    }

    adicionarItemCompra(produto, quantidade);
    atualizarTabelac();
    e.target.reset();
    e.target.entrada.focus();
}
}

  async function buscarProdutoPorCodBarrasc(controle) {
  try {    
    const res = await fetch(`/produtos/codbarras/${controle}`);
    if (!res.ok) return null;
    const produto = await res.json();
    console.log("Fracionado:", produto.fracionado);
    fraccion = produto.fracionado      
    if (!Number.isInteger(quanti) && fraccion != 'SIM') {
      console.log("Quantidade é fracionada:", quantidade);      
      produtonome = produto.produto
      quanti = 0
      srt = 1
      return 
    }
    return produto;
  } catch (err) {
    console.error('Erro ao buscar produto:', err);
    return null;
  }
  }




